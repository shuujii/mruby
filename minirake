#!/usr/bin/env ruby

$stdout.sync=true

#
# === 動機
#
# Rake は起動が遅い (Ruby 2.5 から特に感じる) ので最低限の機能のみを提供する
# ものを利用したい。将来的には mruby オリジナルの MiniRake を改修したい。
#
# === オリジナルからの主な変更点
#
# - ヘルプ系で desc 文字列を表示
# - --prereqs(-P) を追加
# - --tasks(-T) で依存タスクを非表示
# - rule タスクの deps 側で %X などが機能しない問題を修正 (だだし rule の再
#   帰? には未対応)
# - 簡易な namespace サポートを追加
# - DSL で FileUtils のコマンドを使えるようにした
# - mrbgem の pull 機能を削除
# - いくつか Rake との互換性を高めた
#

require 'getoptlong'
autoload :FileUtils, 'fileutils'

class String
  def ext(newext='')
    return self.dup if ['.', '..'].include? self
    if newext != ''
      newext = (newext =~ /^\./) ? newext : ("." + newext)
    end
    self.chomp(File.extname(self)) << newext
  end

  def pathmap(spec=nil, &block)
    return self if spec.nil?
    result = ''
    spec.scan(/%\{[^}]*\}-?\d*[sdpfnxX%]|%-?\d+d|%.|[^%]+/) do |frag|
      case frag
      when '%f'
        result << File.basename(self)
      when '%n'
        result << File.basename(self).ext
      when '%d'
        result << File.dirname(self)
      when '%x'
        result << File.extname(self)
      when '%X'
        result << self.ext
      when '%p'
        result << self
      when '%s'
        result << (File::ALT_SEPARATOR || File::SEPARATOR)
      when '%-'
        # do nothing
      when '%%'
        result << "%"
      when /%(-?\d+)d/
        result << pathmap_partial($1.to_i)
      when /^%\{([^}]*)\}(\d*[dpfnxX])/
        patterns, operator = $1, $2
        result << pathmap('%' + operator).pathmap_replace(patterns, &block)
      when /^%/
        fail ArgumentError, "Unknown pathmap specifier #{frag} in '#{spec}'"
      else
        result << frag
      end
    end
    result
  end
end

$namespaces = []
$verbose = false  # オリジナル minirake との互換のために false の設定が必要
module MiniRake
  class << self
    attr_reader :app

    def run
      @app = MiniRake::App.new
      @app.run
    end
  end

  class Task
    TASKS = Hash.new
    RULES = Array.new

    class << self
      # List of all defined tasks.
      def tasks
        TASKS.keys.sort.collect { |tn| Task[tn] }
      end

      # Return a task with the given name.  If the task is not currently
      # known, try to synthesize one from the defined rules.  If no
      # rules are found, but an existing file matches the task name,
      # assume it is a file task with no dependencies or actions.
      def [](task_name)
        task_name = task_name.to_s
        if task = TASKS[task_name]
          return task
        end
        if task = enhance_with_matching_rule(task_name)
          return task
        end
        if File.exist?(task_name)
          return FileTask.define_task(task_name)
        end
        fail "Don't know how to rake #{task_name}"
      end

      # Define a task given +args+ and an option block.  If a rule with
      # the given name already exists, the prerequisites and actions are
      # added to the existing task.
      def define_task(args, &block)
        name, deps = resolve_args(args)
        task_name = name_with_namespace($namespaces, name)
        lookup(task_name).enhance([deps].flatten, &block)
      end

      # Define a rule for synthesizing tasks.
      def create_rule(args, &block)
        pattern, deps = resolve_args(args)
        pattern = Regexp.new(Regexp.quote(pattern) + '$') if String === pattern
        RULES << [pattern, deps, block]
      end

      # Lookup a task.  Return an existing task if found, otherwise
      # create a task of the current type.
      def lookup(task_name)
        name = task_name.to_s
        TASKS[name] ||= new(name)
      end

      # If a rule can be found that matches the task name, enhance the
      # task with the prerequisites and actions from the rule.  Set the
      # source attribute of the task appropriately for the rule.  Return
      # the enhanced task or nil of no rule was found.
      def enhance_with_matching_rule(task_name)
        RULES.each do |pattern, extensions, block|
          next unless  pattern && pattern.match(task_name)
          sources = extensions.flat_map do |ext|
            case ext
            when /%/
              task_name.pathmap(ext)
            when %r{/}
              ext
            when /^\./
              source = task_name.sub(task_pattern, ext)
              source == ext ? task_name.ext(ext) : source
            when String
              ext
            when Proc, Method
              ext.arity == 1 ? ext.call(task_name) : ext.call
            else
              fail "Don't know how to handle rule dependent: #{ext.inspect}"
            end
          end
          prereqs = sources.map do |source|
            break nil unless File.exist?(source) || TASKS[source]
            source
          end
          if prereqs
            task = FileTask.define_task(task_name => prereqs, &block)
            task.source = prereqs.first
            return task
          end
        end
        nil
      end

      def name_with_namespace(namespaces, name_without_namespace) # :nodoc:
        return name_without_namespace if namespaces.empty?
        "#{namespaces * ':'}:#{name_without_namespace}"
      end

      private

      # Resolve the arguments for a task/rule.
      def resolve_args(args)
        case args
        when Hash
          fail "Too Many Task Names: #{args.keys.join(' ')}" if args.size > 1
          fail "No Task Name Given" if args.size < 1
          task_name = args.keys[0]
          deps = args[task_name]
          deps = [deps] if (String===deps) || (Regexp===deps) || (Proc===deps)
        else
          task_name = args
          deps = []
        end
        [task_name, deps]
      end
    end

    attr_reader :comment

    # List of prerequisites for a task.
    attr_reader :prerequisites

    # Source dependency for rule synthesized tasks.  Nil if task was not
    # sythesized from a rule.
    attr_accessor :source

    # Create a task named +task_name+ with no actions or prerequisites..
    # use +enhance+ to add actions and prerequisites.
    def initialize(task_name)
      @name = task_name
      @prerequisites = []
      @actions = []
      @comment = $last_desc
      $last_desc = nil
    end

    # Enhance a task with prerequisites or actions.  Returns self.
    def enhance(deps=nil, &block)
      @prerequisites |= deps if deps
      @actions << block if block_given?
      self
    end

    # Name of the task.
    def name
      @name.to_s
    end

    # Invoke the task.  Prerequites are invoked first.
    def invoke
      puts "** Invoke #{name} (already=[#{@already_invoked}], needed=[#{needed?}]))" if $trace
      return if @already_invoked
      @already_invoked = true
      prerequisites = @prerequisites.collect{ |n| n.is_a?(Proc) ? n.call(name) : n }.flatten
      prerequisites.each{|n| invoke_prerequisite(n)}
      execute if needed?
    end

    # Execute the actions associated with this task.
    def execute
      puts "** Execute #{name}" if $trace
      self.class.enhance_with_matching_rule(name) if @actions.empty?
      @actions.each { |act| act.call(self) } unless $dryrun
    end

    # Is this task needed?
    def needed?
      true
    end

    # Timestamp for this task.  Basic tasks return the current time for
    # their time stamp.  Other tasks can be more sophisticated.
    def timestamp
      Time.now
    end

    private

    def invoke_prerequisite(prerequisite)
      *namespaces, _n = name.split(":", -1)
      until namespaces.empty?
        n = Task.name_with_namespace(namespaces, prerequisite)
        unless n == name
          task = TASKS[n]
          return task.invoke if task
        end
        namespaces.pop
      end
      Task[prerequisite].invoke
    end
  end

  class FileTask < Task
    # Is this file task needed?  Yes if it doesn't exist, or if its time
    # stamp is out of date.
    def needed?
      return true unless File.exist?(name)
      prerequisites = @prerequisites.collect{ |n| n.is_a?(Proc) ? n.call(name) : n }.flatten
      latest_prereq = prerequisites.collect{|n| Task[n].timestamp}.max
      return false if latest_prereq.nil?
      timestamp < latest_prereq
    end

    # Time stamp for file task.
    def timestamp
      return Time.at(0) unless File.exist?(name)
      stat = File::stat(name.to_s)
      stat.directory? ? Time.at(0) : stat.mtime
    end
  end

  module DSL
    # Create a new rake namespace and use it for evaluating the given block.
    def namespace(name, &block)
      $namespaces << name
      begin
        block.call
      ensure
        $namespaces.pop
      end
    end

    # Declare a basic task.
    def task(args, &block)
      Task.define_task(args, &block)
    end

    # Declare a file task.
    def file(args, &block)
      FileTask.define_task(args, &block)
    end

    # Declare a set of files tasks to create the given directories on
    # demand.
    def directory(args, &block)
      FileTask.define_task(args) do |t|
        block.call(t) unless block.nil?
        dir = args.is_a?(Hash) ? args.keys.first : args
        (dir.split(File::SEPARATOR) + ['']).inject do |acc, part|
          (acc + File::SEPARATOR).tap do |d|
            Dir.mkdir(d) unless File.exists? d
          end + part
        end
      end
    end

    # Declare a rule for auto-tasks.
    def rule(args, &block)
      Task.create_rule(args, &block)
    end

    # Write a message to standard out if $verbose is enabled.
    def log(msg)
      print "  " if $trace && $verbose
      puts msg if $verbose
    end

    # Run the system command +cmd+.
    def sh(*cmd)
      puts cmd * " " if $verbose
      unless system(*cmd)
        fail "Command failed with status (#{$?.exitstatus}): [#{cmd * ' '}]"
      end
    end

    def desc(text)
      $last_desc = text
    end
  end

  module FileUtilsExt
    def self.extended(mod)
      require 'fileutils'
      mod.extend FileUtils

      FileUtils.commands.each do |command|
        opt_names = FileUtils.options_of(command)
        opts = []
        opts << "verbose: $trace || $verbose || $verbose.nil?" if opt_names.include?("verbose")
        opts << "noop: $dryrun" if opt_names.include?("noop")
        next if opts.empty?

        mod.instance_eval <<-EOS,  __FILE__, __LINE__ + 1
          def #{command}(*args, &block)
            default_opts = {#{opts * ", "}}
            default_opts.merge!(args.pop) if Hash === args[-1]
            args << default_opts
            super
          end
        EOS
      end
    end
  end

  ######################################################################
  # Rake main application object.  When invoking +rake+ from the command
  # line, a App object is created and run.
  #
  class App
    NAME = "rake"
    RAKEFILES = ['rakefile', 'Rakefile']

    OPTIONS = [
      ['--dry-run',  '-n', GetoptLong::NO_ARGUMENT,
        "Do a dry run without executing actions."],
      ['--help',     '-H', GetoptLong::NO_ARGUMENT,
        "Display this help message."],
      ['--libdir',   '-I', GetoptLong::REQUIRED_ARGUMENT,
        "Include LIBDIR in the search path for required modules."],
      ['--nosearch', '-N', GetoptLong::NO_ARGUMENT,
        "Do not search parent directories for the Rakefile."],
      ['--prereqs',  '-P', GetoptLong::NO_ARGUMENT,
        "Display the tasks and dependencies, then exit."],
      ['--quiet',    '-q', GetoptLong::NO_ARGUMENT,
        "Do not log messages to standard output (default)."],
      ['--rakefile', '-f', GetoptLong::REQUIRED_ARGUMENT,
        "Use FILE as the rakefile."],
      ['--require',  '-r', GetoptLong::REQUIRED_ARGUMENT,
        "Require MODULE before executing rakefile."],
      ['--silent',   '-s', GetoptLong::NO_ARGUMENT,
        "Like --quiet, but also suppresses the 'in directory' announcement."],
      ['--tasks',    '-T', GetoptLong::NO_ARGUMENT,
        "Display the tasks with descriptions, then exit."],
      ['--trace',    '-t', GetoptLong::NO_ARGUMENT,
        "Turn on invoke/execute tracing."],
      ['--usage',    '-h', GetoptLong::NO_ARGUMENT,
        "Display usage."],
      ['--verbose',  '-v', GetoptLong::NO_ARGUMENT,
        "Log message to standard output."],
      ['--directory', '-C', GetoptLong::REQUIRED_ARGUMENT,
        "Change executing directory of rakefiles."]
    ]

    # Create a App object.
    def initialize
      @rakefile = nil
      @nosearch = false
      @org_dir = Dir.pwd
    end

    # True if one of the files in RAKEFILES is in the current directory.
    # If a match is found, it is copied into @rakefile.
    def have_rakefile
      RAKEFILES.each do |fn|
        if File.exist?(fn)
          @rakefile = fn
          return true
        end
      end
      return false
    end

    # Display the program usage line.
    def usage
      puts "#{NAME} [-f rakefile] {options} targets..."
    end

    # Display the rake command line help.
    def help
      usage
      puts
      puts "Options are ..."
      puts
      OPTIONS.sort.each do |long, short, mode, desc|
        if mode == GetoptLong::REQUIRED_ARGUMENT
          if desc =~ /\b([A-Z]{2,})\b/
            long = long + "=#{$1}"
          end
        end
        printf "  %-20s (%s)\n", long, short
        printf "      %s\n", desc
      end
    end

    # Display the tasks with descriptions
    def display_tasks
      width = Task.tasks.map{|t| t.name.size}.max
      Task.tasks.each do |t|
        printf "#{NAME} %-#{width}s  # %s\n", t.name, t.comment
      end
    end

    # Display the tasks and prerequisites
    def display_prerequisites
      Task.tasks.each do |t|
        puts "#{NAME} #{t.name}"
        t.prerequisites.each { |pre| puts "    #{pre}" }
      end
    end

    # Return a list of the command line options supported by the
    # program.
    def command_line_options
      OPTIONS.collect { |lst| lst[0..-2] }
    end

    # Do the option defined by +opt+ and +value+.
    def do_option(opt, value)
      case opt
      when '--dry-run'
        $dryrun = true
        $trace = true
      when '--help'
        help
        exit
      when '--libdir'
        $:.push(value)
      when '--nosearch'
        @nosearch = true
      when '--prereqs'
        $show_prereqs = true
      when '--quiet'
        $verbose = false
      when '--rakefile'
        RAKEFILES.clear
        RAKEFILES << value
      when '--require'
        require value
      when '--silent'
        $silent = true
        $verbose = false
      when '--tasks'
        $show_tasks = true
      when '--trace'
        $trace = true
      when '--usage'
        usage
        exit
      when '--verbose'
        $verbose = true
      when '--directory'
        Dir.chdir value
      else
        fail "Unknown option: #{opt}"
      end
    end

    # Read and handle the command line options.
    def handle_options
      opts = GetoptLong.new(*command_line_options)
      opts.each { |opt, value| do_option(opt, value) }
    end

    # Run the +rake+ application.
    def run
      handle_options
      begin
        here = Dir.pwd
        while ! have_rakefile
          Dir.chdir("..")
          if Dir.pwd == here || @nosearch
            fail "No Rakefile found (looking for: #{RAKEFILES.join(', ')})"
          end
          here = Dir.pwd
        end
        tasks = []
        ARGV.each do |task_name|
          if /^(\w+)=(.*)/.match(task_name)
            ENV[$1] = $2
          else
            tasks << task_name
          end
        end
        puts "(in #{Dir.pwd})" if !$silent && @org_dir != Dir.pwd
        $rakefile = @rakefile
        load @rakefile
        if $show_tasks
          display_tasks
        elsif $show_prereqs
          display_prerequisites
        else
          TOPLEVEL_BINDING.eval "extend MiniRake::FileUtilsExt"
          tasks.push("default") if tasks.size == 0
          tasks.each do |task_name|
            Task[task_name].invoke
          end
        end
      rescue Exception => ex
        puts "#{NAME} aborted!"
        puts ex.message
        if $trace
          puts ex.backtrace.join("\n")
        else
          puts ex.backtrace.find {|str| str =~ /#{@rakefile}/ } || ""
        end
        exit false
      end
    end
  end
end

Rake = MiniRake
extend MiniRake::DSL
MiniRake.run
